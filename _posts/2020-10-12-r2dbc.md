---
layout: post
authors: [daniele_ninicato]
title: 'R2DBC'
image: /img/R2DBC.jpg
tags: [DATABASE, SPRING, R2DBC, BACKEND]
category: Backend
comments: false
---

# Table of Contents

* [Reactive Programming](#reactive_programming)
* [Demo](#demo)

# Reactive Programming
Trafitional way...
In a traditional environment, lets say, a client makes a request to the server, the server-thread blocks the request until it is finished doing the thing
it needs to do...lets say get some data from the database, and then when the server it finished it returns the response to the client. 
So if the process of getting the data from the database is slow, the server-thread is blocked

so what is reactive programming?
In a reactive environment, when the client makes a request to the server, the server-thread is not blocking the request until it is finished doing
whatever needs to be done, even when it takes a lot of time, but is the server-thread able to take more request and handle them separatly.
it is a publish/subscribe solution without non-blocking backpressure

why is it important?
It is the next frontier in java for high-efficiency applications fundamentally non-blocking, often paired with asynchronous behaviour, but it is completely agnostic to sync/async. 
The most important thing to notice is that there is no back pressure.
		
jdbc limitations...in the end you might hit the database and while you're applicaten may be reactive, the connection to the database is still blocking

# Demo
Using a reactive driver like R2DBC together with Spring WebFlux allows you to write a full application that handles the receiving and sending of data in a reactive way.

### Spring Initializr
I created this sample demo project using Spring Initializr and added the follow dependencies
<ul>
<li>Spring Reactive Web</li>
<li>PostgresSQL Driver</li>
<li>Spring Data R2DBC</li>
<li>Lombok (beceause I'm lazy)</li>
</ul>

<div style="text-align: center;">
  <img alt="Spring Initializr" src="/img/2020-10-12-r2dbc/spring-initializr.jpg" width="auto" height="auto" class="image fit">
</div>

### Dependencies

##### spring-boot-starter-data-r2dbc
This is the primary dependency to enable Spring Data R2DBC. Don’t be confused with spring-boot-starter-r2dbc that only enables R2DBC client without Spring Data implementation.

#### r2dbc-postgresql
Add this when you’re using PostgreSQL.

#### r2dbc-postgresql

<div style="text-align: center;">
  <img alt="Dependencies" src="/img/2020-10-12-r2dbc/dependencies.jpg" width="auto" height="auto" class="image fit">
</div>

### Configuration

<div style="text-align: center;">
  <img alt="Configuration" src="/img/2020-10-12-r2dbc/configuration.jpg" width="auto" height="auto" class="image fit">
</div>
Spring allows you to get all the basic setup by only extending AbstractR2dbcConfiguration and implementing a ConnectionFactory bean
The ConnectionFactory contains details about the connection to the database. This bean is one component of the DatabaseClient. This is an important class, as it is central to the execution of SQL within the Spring Data R2DBC module.
So, extending AbstractR2dbcConfiguration and implementing connectionFactory will get your application up and running very quickly.
The @EnableR2dbcRepositories annotation instructs Spring to find any repository interfaces that extend Spring’s Repository interface. This is used as the base interface for instrumenting Spring Data repositories. We will look at this a little closer in the next section.

### Repository
<div style="text-align: center;">
  <img alt="Repository" src="/img/2020-10-12-r2dbc/repository.jpg" width="auto" height="auto" class="image fit">
</div>

By extending R2DBCRepository, Spring will pick up these queries and instrument them as well as providing some typical queries for you, such as findByAllId. 
This is where the @EnableR2dbcRepositories annotation added earlier comes into play. Without this annotation then this repository will not do anything for you and would instead require a completely manual implementation.
The Flux objects returned from these functions are basically the reactive version of a List. In other words, they return multiple values. These values will be returned and processed as they arrive as long as you have subscribed to the Flux once it has been created.

### The Entity
<div style="text-align: center;">
  <img alt="Model" src="/img/2020-10-12-r2dbc/model.jpg" width="auto" height="auto" class="image fit">
</div>

Although Spring Data R2DBC does not aim to be a fully fledged ORM, it does still provide entity mapping. Below is an entity class that doesn’t really need much explanation
This entity will map to the people table defined below

<div style="text-align: center;">
  <img alt="Create Table" src="/img/2020-10-12-r2dbc/createtable.jpg" width="auto" height="auto" class="image fit">
</div>

### Controller
<div style="text-align: center;">
  <img alt="Controller" src="/img/2020-10-12-r2dbc/controller.jpg" width="auto" height="auto" class="image fit">
</div>

### Testing with Postman
<div style="text-align: center;">
  <img alt="Postman Get" src="/img/2020-10-12-r2dbc/postman-get.jpg" width="auto" height="auto" class="image fit">
</div>

<div style="text-align: center;">
  <img alt="Postman Put" src="/img/2020-10-12-r2dbc/postman-put.jpg" width="auto" height="auto" class="image fit">
</div>

This is not anywhere close to a real representation of how you would use Reactive Streams in a production application but hopefully demonstrates how to use them and gives a bit of insight into how they execute.