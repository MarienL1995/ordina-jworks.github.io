---
layout: post
authors: [daniele_ninicato]
title: 'R2DBC'
image: /img/R2DBC.jpg
tags: [DATABASE, SPRING, R2DBC, BACKEND]
category: Backend
comments: false
---

# Table of Contents

* [Reactive Programming](#reactive_programming)
* [Relational Databases and Reactive](#relational_databases_and_reactive)
* [R2DBC to the Rescue!](#r2dbc_to_the_rescue)
* [Demo](#demo)

# Reactive Programming
There are a lot of answers about what Reactive Programming is and how this compares to Reactive Systems. Reactive Programming is as a programming model that facilitates scalability and stability by creating event-driven non-blocking functional pipelines that react to availability and processability of resources.

The full benefits of reactive programming come into effect only if the entire stack is reactive and if all participating components (application code, runtime container, integrations) respect deferred execution, non-blocking APIs and the streaming nature of dataflow – basically following the underlying assumptions.

While it’s possible to bring non-reactive components to an application that is written in a functional-reactive style, the net result is that the scalability and stability effects, the actual expected benefits, decrease. In the worst case, there’s little or no difference in runtime behavior. However, reactive programming helps to improve the readability of code.

# Relational Databases and Reactive
Java uses JDBC as the primary technology to integrate with relational databases. JDBC is of a blocking nature – there’s nothing sensible one could do to mitigate the blocking nature of JDBC. The first idea for how to make calls non-blocking is offloading JDBC calls to an Executor (typically Thread pool). While this approach somewhat works, it comes with several drawbacks that neglect the benefits of a reactive programming model.

Thread pools require – no surprise – threads to run. Reactive runtimes typically use a limited number of threads that match the number of CPU cores. Additional threads introduce overhead and reduce the effect of thread limiting. Additionally, JDBC calls typically pile up in a queue, and once the threads are saturated with requests, the pool will block again. So, JDBC is right now not an option.

# R2DBC to the Rescue!
Lacking a standard API and the non-availability of drivers, a team at Pivotal started to investigate the idea of a reactive relational API that would be an ideal fit for reactive programming purposes. They came up with R2DBC which stands for Reactive Relational Database Connectivity. As of now, R2DBC is an incubator project to evaluate the feasibility and to start discussions whether driver vendors are interested in supporting reactive/non-blocking/asynchronous drivers.

# Demo
Using a reactive driver like R2DBC together with Spring WebFlux allows you to write a full application that handles the receiving and sending of data in a reactive way.

### Spring Initializr
I created this sample demo project using Spring Initializr and added the follow dependencies
<ul>
<li>Spring Reactive Web</li>
<li>PostgresSQL Driver</li>
<li>Spring Data R2DBC</li>
<li>Lombok (beceause I'm lazy)</li>
</ul>

<div style="text-align: center;">
  <img alt="Spring Initializr" src="/img/2020-10-12-r2dbc/spring-initializr.jpg" width="auto" height="auto" class="image fit">
</div>

### Dependencies

##### spring-boot-starter-data-r2dbc
This is the primary dependency to enable Spring Data R2DBC. Don’t be confused with spring-boot-starter-r2dbc that only enables R2DBC client without Spring Data implementation.

#### r2dbc-postgresql
Add this when you’re using PostgreSQL.

#### r2dbc-postgresql

<div style="text-align: center;">
  <img alt="Dependencies" src="/img/2020-10-12-r2dbc/dependencies.jpg" width="auto" height="auto" class="image fit">
</div>

### Configuration

<div style="text-align: center;">
  <img alt="Configuration" src="/img/2020-10-12-r2dbc/configuration.jpg" width="auto" height="auto" class="image fit">
</div>
Spring allows you to get all the basic setup by only extending AbstractR2dbcConfiguration and implementing a ConnectionFactory bean
The ConnectionFactory contains details about the connection to the database. This bean is one component of the DatabaseClient. This is an important class, as it is central to the execution of SQL within the Spring Data R2DBC module.
So, extending AbstractR2dbcConfiguration and implementing connectionFactory will get your application up and running very quickly.
The @EnableR2dbcRepositories annotation instructs Spring to find any repository interfaces that extend Spring’s Repository interface. This is used as the base interface for instrumenting Spring Data repositories. We will look at this a little closer in the next section.

### Repository
<div style="text-align: center;">
  <img alt="Repository" src="/img/2020-10-12-r2dbc/repository.jpg" width="auto" height="auto" class="image fit">
</div>

By extending R2DBCRepository, Spring will pick up these queries and instrument them as well as providing some typical queries for you, such as findByAllId. 
This is where the @EnableR2dbcRepositories annotation added earlier comes into play. Without this annotation then this repository will not do anything for you and would instead require a completely manual implementation.
The Flux objects returned from these functions are basically the reactive version of a List. In other words, they return multiple values. These values will be returned and processed as they arrive as long as you have subscribed to the Flux once it has been created.

### The Entity
<div style="text-align: center;">
  <img alt="Model" src="/img/2020-10-12-r2dbc/model.jpg" width="auto" height="auto" class="image fit">
</div>

Although Spring Data R2DBC does not aim to be a fully fledged ORM, it does still provide entity mapping. Below is an entity class that doesn’t really need much explanation
This entity will map to the people table defined below

<div style="text-align: center;">
  <img alt="Create Table" src="/img/2020-10-12-r2dbc/createtable.jpg" width="auto" height="auto" class="image fit">
</div>

### Controller
<div style="text-align: center;">
  <img alt="Controller" src="/img/2020-10-12-r2dbc/controller.jpg" width="auto" height="auto" class="image fit">
</div>

### Testing with Postman
<div style="text-align: center;">
  <img alt="Postman Get" src="/img/2020-10-12-r2dbc/postman-get.jpg" width="auto" height="auto" class="image fit">
</div>

<div style="text-align: center;">
  <img alt="Postman Put" src="/img/2020-10-12-r2dbc/postman-put.jpg" width="auto" height="auto" class="image fit">
</div>

This is not anywhere close to a real representation of how you would use Reactive Streams in a production application but hopefully demonstrates how to use them and gives a bit of insight into how they execute.