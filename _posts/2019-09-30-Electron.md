---
layout: post
authors: [tim_vierbergen]
title: 'Electron: Developing and building cross-platform'
image: /img/electron/electron-logo.png
tags: [Continuous Integration,E2E,JavaScript,Testing,Electron,]
category: JavaScript
comments: true
---

# Table of contents
1. [Intro](#intro)
2. [Electron](#electron)
3. [Angular](#angular)
4. [Adding Electron](#adding-electron)
5. [Electron Bridge](#electron-bridge)
6. [E2E Testing: Spectron](#e2e-testing-spectron)
6. [Building And Packaging](#building-and-packaging)
7. [Conclusion](#conclusion)

# Intro

A use case arose where we were in need of a cross-platform desktop application.
Times where we were building native desktop applications, is left behind already some years ago.
For the last few years we were focussing on web-based applications with a focus on Angular.
Because of this shift, most of our teams frontenders are only specialised in JavaScript/TypeScript, in Angular.

For cross-mobile platforms, we've been using `Cordova` for quite some years now.
We've done some proof of concepts with `NativeScript` and `ReactNative`, but are still using `Cordova` so far.
Again, all those apps are written in TypeScript/Javascript.

Because of this, we've started looking for desktoplike application platforms, with implementation code written in JavaScript.
Before we even started, we actually already knew `Electron` would be a match.
For some years now, I've been using Deezer app, Atom, Visual Studio Code, ... .
All desktop applications written in Electron.
Proof it works.




<div style="height: 100px; display:flex;justify-content:flex-start;" >
  <img src="/img/electron/atom.png" width="20%">
  <img src="/img/electron/github-logo.png" width="20%">
  <img src="/img/electron/visual-studio-code.jpg" width="20%">
  <img src="/img/electron/deezer-logo.png" width="20%">
</div>


# Electron

<div style="text-align: center;" >
  <img src="/img/electron/electron-logo.svg.png" width="40%">
</div>

> Build cross platform desktop apps with JavaScript, HTML, and CSS
~<a target="\_blank" href="https://electronjs.org/">Electronjs</a>

"If you can build a website, you can build a desktop app. Electron is a framework for creating native applications with web technologies like JavaScript, HTML, and CSS. It takes care of the hard parts so you can focus on the core of your application."
And that was exactly what we needed.
Based on production ready applications like Atom and Deezer desktop app, we knew we were going for a mature solution.

Electron is wrapping your web-app, and runtime/browser into one package.
To develop the app and wrap it, you need a Nodejs runtime, so make sure it is installed.

You can check this by running:
`$ node -v && npm -v`
If you don't have it, please install it.

Because Electron is just wrapping* your JavaScript, you can make use of several frameworks to build you web-app to javascript before wrapping it.

*There is a communication bridge between you own web-app and the electron interface as well.*

If you are familiar with Vuejs or React, feel free to use them, but for this post we are going to bootstrap it starting from an angular 8 app.

# Angular

<div style="text-align: center;" >
  <img src="/img/electron/angular-logo.png" width="40%">
</div>

We will start setting up our `Angular` app by creating it thought the Angular-cli.
If you don't have it, you can install it by running `$ npm i -g @angular/cli`.
Don't forget about `sudo`.

Then create your application by running:
`$ ng new electron-demo-app --style=scss --routing --interactive=true`

This command will create a new angular application in a subdirectory called `electron-demo-app`.

Go into the directory and run `$ ng serve`.
Open your preferred browser and navigate to `localhost:4200`.
You should see a standard angular app showing up.
(Depending on your angular(cli) version)
<div style="text-align: center;" >
  <img src="/img/electron/base-angular.png" width="80%">
</div>

We will now refactor this app so it looks a bit more professional ;-).

## Base application ##

It's not that important for this post, but in a few steps I will explain what I did.
First of all, I've added angular material:
`$ ng add @angular/material`.
And to set it up, I will redirect you to the <a target="\_blank" href="https://material.angular.io/guide/getting-started">Getting Started documentation</a> of Angular Material.

Instead of importing all your material dependencies in your `app.module.ts`, I always create a separate `module` file called `material.module.ts`, which I then import in all the modules (if needed).
```JavaScript
import { NgModule } from '@angular/core';
import { MatButtonModule, MatIconModule, MatSidenavModule, MatListModule, MatMenuModule,
  MatToolbarModule, MatTableModule, MatPaginatorModule, MatSortModule, MatCardModule,
  MatCheckbox, MatCheckboxModule, MatDialogModule, MatDividerModule } from '@angular/material';
  import { DragDropModule } from '@angular/cdk/drag-drop';


@NgModule({
  declarations: [
      ],
  imports: [
    MatButtonModule,
    MatIconModule,
    MatSidenavModule,
    MatMenuModule,
    MatToolbarModule,
    MatCardModule,
    MatCheckboxModule,
    MatDialogModule,
    DragDropModule
  ],
  exports: [
    MatButtonModule,
    MatIconModule,
    MatSidenavModule,
    MatMenuModule,
    MatToolbarModule,
    MatCardModule,
    MatCheckboxModule,
    MatDialogModule,
    DragDropModule
  ]
})
export class MaterialModule { }
```
For this demo app, you only need a few.
I've added a `<mat-toolbar>` at the top and a `<mat-sidenav>` on the left.
A `hamburger` was added to show and hide the sidenav from within the toolbar.

For the sidenav routing options, I quickly used the cli to generate some modules and components.
`$ ng g m modules/clients --routing`.
And the add the module as lazy route to your `app-routing.module.ts`:

```JavaScript
{
    path: "clients",
    loadChildren: () =>
      import("./modules/clients/clients.module").then(m => m.ClientsModule)
},
```
Same for the dashboard and products modules.

At the top right, I've added a `<mat-icon>people</mat-icon>` that will trigger a context menu.
When you click on logout, a modal dialog will show up for confirmation.
I've added drag and drop to it, so you can drag it around your screen.
As you can see, it will always be part of your DOM.

You can see a small demo video for the basic app online <a target="\_blank" href="https://www.loom.com/share/9a5670dbf4cd49a08d706350a7e0bd73">here</a>.

# Adding Electron

Now that we have created our basic Angular application, the  next step is wrapping it in an Electronjs app.

First of all install Electron in you package.
`$ yarn add --dev electron`
and maybe globally
`$ yarn global add electron`

Before we start setting up the electron part, we are first going to change the `base-href` from our angular application.
The moment we are running our application in electron, it's being served from the local file system.
Some saying setting the base-href to `<base href=”./”>` is a solution for not getting routing and file loading errors.

I'm setting the `RouterModule.forRoot(routes,  { useHash: true })` so live reload will be working once your app is on a specific route.

## Electron entry file

We now have electron installed and our Angular application ready to get build and served.
The first thing we now need is an `entry`-file.
This is the starting point for bootstrapping the electron application which is going to serve/run our angular app.

### Development

#### Setting up dependencies and running config

When we want to run the electron application, and let it listen to the changes we are making in our Angular application while developing, we can make electron serve the app from the localhost:4200 url.

To make this more easy, we are going to use `concurrently`, to run both processes together and use `wait-on` to make our process wait for the angular serve result, before starting the electron app.
`$ yarn add --dev concurrently wait-on`
and
```Javascript
"electron:dev": "electron  ./electron/entry.dev.js",
"start:demo-app": "concurrently \"ng serve \" \" wait-on http://localhost:4200 && yarn electron:dev \"",
```
in our package.json scripts.

#### Entry file for development

```Javascript
const { app, BrowserWindow } = require('electron')
let win;

function createWindow () {
  win = new BrowserWindow({
    width: 1900,
    height: 1200,
    icon: `file://${__dirname}/dist/assets/logo.png`
  })

  win.loadURL(`http://localhost:4200`)

  // during development, make devtools open on startup
  win.webContents.openDevTools()

  // Event when the window is closed.
  win.on('closed', function () {
    win = null
  })
}

// Create window on electron intialization
app.on('ready', createWindow)

// Quit when all windows are closed.
app.on('window-all-closed', function () {
  // On macOS specific close process
  if (process.platform !== 'darwin') {
    app.quit()
  }
})

app.on('activate', function () {
  // macOS specific close process
  if (win === null) {
    createWindow()
  }
})
```
This entry file is pretty straightforward.
When the electron process initialises it needs to open a window.
We are providing some options to this window, like width and height.
We then tell this window, it can get it's content by setting the `loadURL`.
Because we are still in development mode for our angular application, we point it to the `localhost:4200` where our web-app is running.
Whenever code from the angular app is changed, the watcher from angular will rebuild it's code, and then refresh the web-app.
Because of this, the electron will refresh as well, and the new version of the angular application will appear in the electron app.
The `baseRef` in this case, isn't that important because the web-server is taking care of the content.

### Building and releasing

When your angular application is ready, you don't want to load it from the `localhost:4200`.
You first build the angular application to your `dist` folder and then serve the builded application in the electron application.

#### Setting up the build for Angular

First add the script to your package.json:
```JavaScript
"electron:dev": "electron  ./electron/entry.js",
"run:prod": "ng build --prod --base-href ./ && yarn electron:dev"
```
Before we can run this, we need the `entry.js`-file and the `ng build --prod` settings.
As you can see, we are setting the `base-href`-property to `./`.
Because we are now going to serve the files straight from the harddisk.

#### Angular build

The `ng build --prod` will build the application, instead if defined otherwise, to it's default `dist/PROJECT_NAME`-directory.
In our case this will be `dist/electron-demo-app`.
This is important for our electron entry file.

#### Entry file for production
```JavaScript

const { app, BrowserWindow } = require('electron')
let win;

function createWindow () {
  let win = new BrowserWindow({
      width: 1900,
      height: 1200,
      icon: `file://${__dirname}/../dist/electron-demo-app/favicon.png`
    })

    const urlFormat = url.format({
      pathname: path.join(__dirname,'..', 'dist', 'electron-demo-app', 'index.html'),
      protocol: 'file:',
      slashes: true
    })
    win.loadURL(urlFormat);

  // Event when the window is closed.
  win.on('closed', function () {
    win = null
  })
}

// Create window on electron intialization
app.on('ready', createWindow)

// Quit when all windows are closed.
app.on('window-all-closed', function () {
  // On macOS specific close process
  if (process.platform !== 'darwin') {
    app.quit()
  }
})

app.on('activate', function () {
  // macOS specific close process
  if (win === null) {
    createWindow()
  }
})

```


When not pointing to a specific entry file when starting electron (eg `electron .`), electron will look in your package.json file for the `main`-property.
If we want we can set it to
`"main": "./electron/entry.js"`

So, executing `yarn run:prod`, will first build a production build with `baseRef` set to `./` and will then start the electron application based on the builds result. You can find the demo <a target="\_blank" href="https://www.loom.com/share/8a924d06dfcc469b8e6564d84a6b4342">here</a>.

# Electron Bridge

In this part we are going to show you how you can `fill` the gap between the Angular application code and the Electron API.
This API is available in the application by importing the `electron`-library installed by running:
`$ yarn add --dev electron`.

The first thing you need to understand is that a normal Angular web application runs in a browser, but is served from a web-server.
An electron application runs on your local machine, in a JavaScript, NodeJs, process.
Therefore it has more possibilities.
You can read all about them in the original <a target="\_blank" href="https://electronjs.org/docs/api">docs</a>.

In the `entry.js`-file, we are importing this API by requiring the library.
This is outside of our Angular application.
For the Angular application, it gets more interesting.
When running the Angular application in your webbrowser (eg `$ ng serve`), you don't have access to the `electron`-environment.
Calling this API will result in an error.
Therefore you need to be able to test in which environment you are running before executing `electron` specific code.

For checking if you are running in the electron environment, you could do something like
`window.navigator.userAgent.match(/Electron/);`.
Or testing if you can `require` a library, you could do something like:
```JavaScript
if (window && window.require) {
    // require electron
    ... = window.require('electron');
}
```
If `true`, you can then require the library and start using the API.
As we don't want to reinvent the wheel, we can use <a target="\_blank" href="https://github.com/ThorstenHans/ngx-electron/tree/master/projects/ngx-electron">`ngx-electron`</a>.
This library wraps the API and exposes it with some checks to make it safe.

```Javascript
import * as Electron from 'electron';

private _electron: Electron.RendererInterface;
....
private get electron(): Electron.RendererInterface {
    if (!this._electron) {
        if (window && window.require) {
            this._electron = window.require('electron');
            return this._electron;
        }
        return null;
    }
    return this._electron;
}
...
public get isElectronApp(): boolean {
    return !!window.navigator.userAgent.match(/Electron/);
}
...
public get ipcRenderer(): Electron.IpcRenderer {
    return this.electron ? this.electron.ipcRenderer : null;
}
...
public get remote(): Electron.Remote {
    return this.electron ? this.electron.remote : null;
}
...
```
You can extend this service or just use it in our components.

```JavaScript
if (this.electronService.isElectronApp) {
  const window = this.electronService.remote.getCurrentWindow();
  window.close();
}
```
## Refactoring the logout modal dialog

As explained before, we need to make it work for a normal web application, and the wrapped Electron app.
So while refactoring, we need to keep in mind that we don't just replace everything.

```JavaScript
openDialog(): void {
  if (this._electronService.isElectronApp) {
    this._openElectronDialog();
  } else {
    this._openMaterialDialog();
  }
}

private _openMaterialDialog(): void {
  const dialogRef = this.dialog.open(LogoutDialog, {
    width: '250px',
    data: {message: 'Sure you want to logout ?'}
  });

  dialogRef.afterClosed().subscribe(result => {
    console.log('The dialog was closed');
  });
}

private _openElectronDialog(): void {
  const {dialog} = this._electronService.remote;
  const options = {
      type: 'warning',
      buttons: ['OK'],
      title: 'Logout',
      message: 'Logout',
      detail: 'Are you sure you want to logout'
  };
  dialog.showMessageBox(null, options).then((response) => {
      const window = this._electronService.remote.getCurrentWindow();
      window.close();
  });  
}
```
Don't forget to import `ngx-electron`.
As you can see, we first check the environment and then open the right dialog.

Note: If this is not working for you, you might wanna add a new option to the BrowserWindow.
From `version 5`, this property is set to false by default.
```JavaScript
win = new BrowserWindow({
    width: 1200,
    height: 800,
    webPreferences: {
      nodeIntegration: true
    }
})
```

You can find the demo <a target="\_blank" href="https://www.loom.com/share/7e7979030b0a4b73aac862fe8f4e4245">here</a>.

The above is for using `Electron`-functionality straight from within our Angular-application.
As shown before, for our electron application, we have an entry file that loads our application, opens a browser window and then runs our angular-application.
What if, for example, we want to communicate between our electron application itself, and Angular.

The `Electron`-applicaion has a main process called, ipcMain (`const {ipcMain} = require('electron');`) and some renderer processes, `ipcRenderer` objects, that are available through our `ElectronService` from `ngx-electron`.
Just as with normal `EventEmitters` and `EventListeners`, you can emit and receive messages through those channels.

```JavaScript
this.ipcRenderer.send('do-something');
```

```JavaScript
ipcMain.on('do-something', (event, arg) => {
    this.doSomething();
});
```

You can find the docs for this <a target="\_blank" href="https://electronjs.org/docs/api/ipc-main">here</a>.


# Building And Packaging

Now that we know how we can build our Angular app and wrap it in an `Electron`-container, we need to take it to the next level and package our app for distribution.
Based on your target platform, you need to package your application accordingly.

When going through the docs that you can find <a target="\_blank" href="https://electronjs.org/docs/tutorial/application-distribution">here</a>, `Electron` itself is recommending one of these 3 options:
* electron-forge
* electron-builder
* electron-packager

We went for the second one.
The flow itself is as follows:
* First, you build the Angular application.
* Second, you wrap it in the electron app.
* And as a last step, you package it, based on your target platform(s).

You can read everything about electron-builder in their <a target="\_blank" href="https://www.electron.build/">docs</a>.

Note: When we started, we were still implementing the 2 `package.json` strategy recommended by electron-builder itself.
You can read all about it <a target="\_blank" href="https://www.electron.build/tutorials/two-package-structure">here</a> and why we are now skipping this part.

Let's start by adding this dependency to our project.
`$ yarn add --dev electron-builder`

Because I am developing on a Macbook, we will start with an Mac Osx build.

```
"pack": "build --dir",
"dist": "build"

  "build": {
    "appId": "be.ordina.electron.demo",
    "category": "electron.demo",
    "productName": "Electron Demo App",
    "copyright": "Copyright © 2019 VeeTeeDev",
    "dmg": {
      "contents": [
        {
          "x": 110,
          "y": 150
        },
        {
          "x": 240,
          "y": 150,
          "type": "link",
          "path": "/Applications"
        }
      ]
    }
  }
```

# E2E Testing: Spectron



## Docker

# Conclusion
